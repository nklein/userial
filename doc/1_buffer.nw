% -*- mode: Noweb; noweb-code-mode: lisp-mode -*-
@
\section{Buffer Handling}

To serialize, one needs a place to put the data.  To unserialize, one
needs a place from which to fetch the data.  Some libraries choose to
implement such things as streams.  The \userial library serializes to
and unserializes from memory buffers because the primary goal for
this library is to facility assembly and disassembly of datagram
packets.

The \userial library uses adjustable arrays of unsigned bytes with
fill pointers.  The fill pointer is used to track the current position
in the buffer for serializing or unserializing.  The buffers are
automatically resized to accomodate the serialized data.

The basic types and constants used for buffer-related operations are
described in \S\ref{sec:buf-types} below.

The \userial library provides a function for allocating a new buffer.
This function is described in \S\ref{api:make-buffer} below.

Many \userial library routines that use a buffer declare the
buffer parameter as optional.  There is a macro one can use to
execute a body of statemets with a particular buffer as the
default for calls in which the buffer parameter is omitted.
This macro is described in \S\ref{api:with-buffer} below.

There are a variety of functions provided to allow one to
query and manipulate the size of \userial buffers.  These functions
are described below in \S\ref{api:buffer-manip}.

There are some basic functions for adding an unsigned byte to
a buffer and retrieving an unsigned byte from a buffer.  Those
functions are described below in \S\ref{api:add-byte}

\subsection{Buffer-related Types and Constants}
\label{sec:buf-types}

The \userial buffers are adjustable arrays of unsigned bytes with fill
pointers.  The array is adjustable so that it can be easily grown as
needed to accomodate serialized data.  It has a fill pointer that is
used to track the current length of serialized data (as distinguished
from the current allocated capacity of the array) or the current point
from which data will be unserialized.
<<buffer type>>=
(deftype buffer () '(array (unsigned-byte 8) (*)))
@ %def buffer

When one creates a \userial buffer, one can provide the initial
capacity for the buffer.  If no initial capacity is given for the
buffer, a default size is used.
<<default buffer capacity>>=
(defconstant +default-buffer-capacity+ 32768)
@ %def +default-buffer-capacity+

When one is adding bytes to a buffer, it would be very inefficient to
reallocate the buffer each time an additional byte of space is needed.
To this end, when the \userial library needs to increase the size of a
buffer it adds at least the minimum of the current buffer size and
this [[+default-buffer-expand+]].
<<default buffer growth size>>=
(defconstant +default-buffer-expand+ 8192)
@ %def +default-buffer-expand+
For example, if the buffer were currently 256 bytes when the buffer
needed to grow by a byte, it would be expanded to 512 bytes.  If the
buffer were currently 10,000 bytes when the buffer needed to grow by a
byte, it would be expanded to 18,192 bytes.
@

\subsection{Creating Buffers}
\label{api:make-buffer}

The buffer allocator itself is the [[make-buffer]] function.  It takes
an optional parameter specifying the initial capacity of the buffer.
<<make-buffer declaration>>=
(ftype (function (&optional (integer 1 *)) buffer) make-buffer)
(defun make-buffer (&optional initial-capacity)
  ...)
@ %def make-buffer
As the buffer will be resized as needed, this parameter need not be
set high enough to accomodate any and all serializations.  It is
provided merely to keep from having to reallocate the buffer several
times if one can provide a decent, probable upper bound on the
serialized size of the contents.
@

\subsection{Using a Buffer}
\label{api:with-buffer}

Most of the buffer manipulation and serialization functions declare
the buffer as optional.  The following macro allows one to specify
the buffer to use for these functions when the buffer parameter is
omitted.
<<with buffer macro>>=
(defmacro with-buffer (buffer &body body))
@ % def with-buffer

This macro assigns the dynamic variable [[*buffer*]] to be
the given buffer for the duration of the body.
<<buffer variable>>=
(declaim (special *buffer*))
@

\subsection{Manipulating and Querying Buffer Sizes}
\label{api:buffer-manip}

When serializing a buffer, the [[buffer-length]] function returns
the current length of the serialized data within the buffer.  When
unserializing a buffer, the [[buffer-length]] function returns the
current length of the serialized data which has already been
unserialized from the buffer.
<<buffer length>>=
(ftype (function (&optional buffer) (integer 0 *)) buffer-length)
(defun buffer-length (&optional (buffer *buffer*))
  ...)
@ %def buffer-length

The current allocated size of a buffer can be queried with the
[[buffer-capacity]] function.  One can [[(setf ...)]] the
[[buffer-capacity]] if needed to explicitly modify the amount of
buffer space allocated.
<<buffer capacity>>=
(ftype (function (&optional buffer) (integer 0 *)) buffer-capacity)
(defun buffer-capacity (&optional (buffer *buffer*))
  ...)
(setf (buffer-capacity &optional (buffer *buffer*)) (integer 0 *))
@ %def buffer-capacity

One can advance the current position within the buffer either to save
space for later serialization or to skip over bytes during
unserialization.
<<buffer advance>>=
(ftype (function (&optional (integer 0 *) buffer) buffer) buffer-advance)
(defun buffer-advance (&optional (advance-by 1) (buffer *buffer*)))
  ...)
@ %def buffer-advance
If not specified, the [[buffer-advance]] function advances by a single
byte.
@

One can reset the current position within the buffer back to the
beginning to begin unserializing a serialized buffer, to fill in
places that one skipped during the first stage of serialization, or to
re-use the same buffer for the next serialization.
<<buffer rewind>>=
(ftype (function (&optional buffer) buffer) buffer-rewind)
(defun buffer-rewind (&optional (buffer *buffer*))
  ...)
@ %def buffer-rewind

\subsection{Adding and Retrieving Bytes}

At its base, the buffer class is an adjustable array of unsigned bytes.
To add a byte to a buffer, one can use the following function.  This
function will expand the buffer if needed, place the given byte at
the current fill pointer and advance the fill pointer.
<<buffer add byte>>=
(ftype (function (uchar &optional buffer) buffer)
       buffer-add-byte)
(defun buffer-add-byte (byte &optional (buffer *buffer*))
@ %def buffer-add-byte

Similarly, to retrieve an unsigned byte from a buffer, one can use
the following function.  This function will retrieve the byte at
the current fill pointer and advance the fill pointer.
<<buffer add byte>>=
(ftype (function (&optional buffer) (values uchar buffer))
       buffer-get-byte)
(defun buffer-get-byte (&optional (buffer *buffer*))
@ %def buffer-get-byte
